The Ampex (`&X`) library provides a Metavariable X that can be used in conjunction with the unary ampersand to create anonymous blocks in a slightly more readable way than the default. It was inspired by the clever `Symbol#to_proc` method which handles the most common case very elegantly, and discussion with Sam Stokes who created an earlier version.

Usage
-----

At its simplest, `&X` can be used as a drop-in replacement for `Symbol#to_proc`:

    [1,2,3].map &X.to_s
      # => ["1", "2", "3"]

However the real strength in the library comes from allowing you to call methods with arguments:

    [1,"2",3].select &X.is_a?(String)
      # => ["2"]

And to chain method calls:

    [1, 2, 3].map &X.to_f.to_s
      # => ["1.0", "2.0", "3.0"]

As everything in Ruby is a method call, you can create readable expressions without the noise of a one-argument block:

    [{1 => 2}, {1 => 3}].map &X[1]
      # => [2, 3]

    [1,2,3].map &-X
      # => [-1, -2, -3]

    ["a", "b", "c"].map &(X * 2)
      # => ["aa", "bb", "cc"]

    [{}].each &X[1] = 2
      # => [{1 => 2}]

You can use this in any place a block is expected, for example to create a lambda:

    normalizer = lambda &X.to_s.downcase
    normalizer.call :HelloWorld
      # => "helloworld"

Gotchas
-------

There are a few things to watch out for:

Firstly, `&X` can only appear on the left:

    [1, 2, 3].map &(X + 1)
      # => [2, 3, 4]

    [1, 2, 3].map &(1 + X) # WRONG
      # => TypeError, "coerce must return [x, y]"

    [[1],[2]].map &X.concat([2])
      # => [[1, 2], [2, 2]]

    [[1],[2]].map &[2].concat(X) # WRONG
      # => TypeError, "Metavariable#to_ary should return Array"

Secondly, other arguments or operands will only be evaluated once, and not every time:

    i = 0
    [1, 2].map &(X + (i += 1)) # WRONG
      # => [2, 3]

    i = 0
    [1, 2].map{ |x| x + (i += 1) }
      # => [2, 4]

Bugs
----

In normal usage there are no known bugs. That said, if you accidentally miss the `&` from in front of the `X`, in an expression that ends in an assignment (e.g. `X.formatter = :inspect`); then the `#to_proc` method of the object assigned will respond with the expression generated by that `X` the next time you call it from anywhere else in the same thread.

Epilogue
--------

`&X` has been tested on MRI ruby 1.8.6, 1.8.7 and 1.9.2 and jruby 1.5.3. It is thread-safe.

For bug-fixes or enhancements, please contact the author: Conrad Irwin <conrad.irwin@gmail.com>

For an up-to-date version, try <https://github.com/rapportive-oss/ampex>

This library is copyrighted under the MIT license, see LICENSE.MIT for details.

See also
--------

* <https://github.com/danielribeiro/RubyUnderscore> â€” which uses an underscore in place of `&X` and works by rewriting the syntax tree.
